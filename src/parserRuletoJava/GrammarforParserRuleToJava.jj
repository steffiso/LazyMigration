/**
 * JavaCC template file created by SF JavaCC plugin 1.5.28+ wizard for JavaCC 1.5.0+
 */options{  static = false;}PARSER_BEGIN(ParserRuleToJava)package parserRuletoJava;import java.util.ArrayList;import datalog.Predicate;import datalog.Rule;import datalog.Condition;import datalog.RuleBody;
import database.Database;
import database.Schema;
import java.util.SortedMap;
import java.util.TreeMap;public class ParserRuleToJava{
//  public Schema getSchema(String kind, int schemaNumber)//  {//    Database db = new Database();//    Schema currentSchema = db.getSchema(kind, schemaNumber);//    return currentSchema;//  }
}PARSER_END(ParserRuleToJava)SKIP :{  " "| "\r"| "\t"| "\n"}TOKEN : /* Zeichen */{  < variable :    "?" < kindValue > (< number >)?     (      "~"      (        < number >      | < string >      )    )? >| < string : "'" (~[ "'" ])* "'" >| < operators :    "<"  | ">"  | "!"  | "=" >| < number :    (< digit >)+    (      "." (< digit >)+    )? >| < digit : [ "0"-"9" ] >| < not : "not" >| < kindValue : < nameValue > (< nameValue >)* >| < nameValue :    [ "a"-"z" ]  | [ "A"-"Z" ]  | "-"  | "_" >}ArrayList < Rule > start() :{  ArrayList < Rule > querys = new ArrayList < Rule > ();  RuleBody p = null;  Predicate leftRelation = null;  Rule q = null;}{  (    leftRelation = getRelation() ":-" p = getRelationList()    {      q = new Rule(leftRelation, p);      //if (!p.conditions.isEmpty()) q.setConditions(p.conditions);      querys.add(q);    }    "."    (      (        leftRelation = getRelation() ":-" p = getRelationList()        {          q = new Rule(leftRelation, p);          //if (!p.conditions.isEmpty()) q.setConditions(p.conditions);          querys.add(q);        }        "."      )    )*  )?  < EOF >  {    return querys;  }}RuleBody getRelationList() :{  ArrayList < Predicate > values = new ArrayList < Predicate > ();  ArrayList < Condition > conditions = new ArrayList < Condition > ();  Predicate predicate = null;  Condition condition = null;}{  (    (      (        predicate = getRelation()        {          values.add(predicate);        }      )    |      (        condition = getCondition()        {          conditions.add(condition);        }      )    )    (      ","      (        (          predicate = getRelation()          {            values.add(predicate);          }        )      |        (          condition = getCondition()          {            conditions.add(condition);          }        )      )    )*  )?  {    return new RuleBody(values, conditions);  }}Predicate getRelation() :{  Token kind = null;  Token schemaToken = null;  String value = null;
  String attribute = null;  SortedMap <String, String > values = new TreeMap <String, String > ();  Predicate predicate = null;
  Schema schema = null;  boolean isNot = false;}{  (< not >  {    isNot = true;  }  )? (kind = < kindValue >) (schemaToken = < number >)? "("  (	    value = getValue()
	    {		      
		    if (value.startsWith("?"))		    {
		      attribute = value;
		      value = "";
		    }
		    else
		    	attribute = "";
		    	//toDO: aus Schema den Attributsnamen rausbekommen und in Map schreiben !!      
		    	//attribute = getAttributeName(kind, schemaToken, pos);		    {		      values.put(attribute, value);		    }
	  	}	    (              	      ","	      (
	                  
	        value = getValue()
	        {	          
			    if (value.startsWith("?"))
			    {
			      attribute = value;
			      value = "";
			    }
				else
					attribute = "";		        {		          values.put(attribute, value);		        }
		    }	      	      )    	    )*	  )?  ")"  {    predicate = new Predicate(kind.toString() + schemaToken.toString(), values.size(), values);    if (isNot) predicate.setNot(true);    return predicate;  }}Condition getCondition() :{  String right = null;  String left = null;  Token operator = null;}{  left = getValue() operator = < operators > right = getValue()  {    Condition con = new Condition(left, right, operator.toString());    return con;  }}String getValue() :{  Token valueOfToken = null;}{  (    valueOfToken = < variable >  | valueOfToken = < number >  | valueOfToken = < string >  )  {    return valueOfToken.toString();  }}