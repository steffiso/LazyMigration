/**
 * JavaCC template file created by SF JavaCC plugin 1.5.28+ wizard for JavaCC 1.5.0+
 */options{  static = false;}PARSER_BEGIN(ParserQueryToDatalogToJava)package parserQueryToDatalogToJava;import java.io.BufferedReader;import java.io.File;import java.io.FileReader;import java.io.IOException;import java.util.ArrayList;import java.sql.Timestamp;import java.util.Date;import java.io.PrintWriter;import java.io.BufferedWriter;import java.io.FileWriter;
import java.io.StringReader;import database.Database;import database.Schema;
import datalog.Rule;import parserRuletoJava.ParserRuleToJava;
public class ParserQueryToDatalogToJava{

  public String kindStr;
  public String idStr;
  private static ArrayList <Rule > rules = new ArrayList<Rule >();
    private static ArrayList < String > getCurrentSchema(String kind)  {    Database db = new Database();    Schema currentSchema = db.getLatestSchema(kind);    ArrayList < String > attributes = currentSchema.getAttributes();    return attributes;  }  private static String schemaToString(ArrayList < String > schema)  {    String schemaStr = "";    for (String s : schema)    {      schemaStr = schemaStr + s + ",";    }    schemaStr = schemaStr.substring(0, schemaStr.length() - 1);    return schemaStr;  }  private static int getCurrentSchemaVersion(String kind)  {    Database db = new Database();    int currentSchemaVersion = db.getLatestSchemaVersion(kind);    return currentSchemaVersion;  }  private static ArrayList < String > getNewSchemaDelete(String kind, String value)  {    ArrayList < String > currentSchema = getCurrentSchema(kind);    ArrayList < String > tempNewSchema = new ArrayList < String > ();    for (String attribute : currentSchema)    {      if (!attribute.equals("?" + value)) tempNewSchema.add(attribute);    }    return tempNewSchema;  }  private static ArrayList < String > getNewSchemaAdd(String kind, String value)  {    ArrayList < String > currentSchema = getCurrentSchema(kind);    currentSchema.add(value);    return currentSchema;  }  private static void saveCurrentSchema(String kind, ArrayList < String > newSchema)  {    Database db = new Database();    ArrayList < String > currentSchema = getCurrentSchema(kind);    if (!currentSchema.equals(newSchema))    {      db.saveCurrentSchema(kind, newSchema);    }  }  private static String getResidualRules(String kind)  {    String value = null;    ArrayList < String > schema = getCurrentSchema(kind);    int currentVersion = getCurrentSchemaVersion(kind);    ArrayList < String > secondSchema = new ArrayList < String > ();    secondSchema.addAll(schema);    for (int i = 0; i < secondSchema.size(); i++)    {      String s = secondSchema.get(i);      if (!s.equals("?id"))      {        secondSchema.set(i, s + "2");      }    }    value = "legacy" + kind + currentVersion + "(?id,?ts):-" + kind + currentVersion + "(" + schemaToString(schema) + ",?ts)," +     kind + currentVersion + "(" + schemaToString(secondSchema) + ",?nts), ?ts < ?nts.\n" +     "latest" + kind + currentVersion + "(?id,?ts):-" + kind + currentVersion + "(" + schemaToString(schema) + ",?ts), not legacy" + kind + currentVersion + "(?id,?ts).\n";
    
	try
	{  
    	rules.addAll((new ParserRuleToJava(new StringReader(value))).start());
	} catch (parserRuletoJava.ParseException e) {
		// TODO Auto-generated catch block
		e.printStackTrace();
	}
	    return value;  }  private static int getTimestamp()  {    Database db = new Database();    int time = db.getLastTimestamp();    return time + 1;  }

    public ArrayList < String > getSchema(String kind, int schemaNumber)
  {
    Database db = new Database();
    Schema currentSchema = db.getSchema(kind, schemaNumber);
    if (currentSchema != null)
    	return currentSchema.getAttributes();
    else
    	return null;
  }

  public String getAttributeName(String kind, int schemaNumber, int pos)
  {
    Database db = new Database();
    Schema currentSchema = db.getSchema(kind, schemaNumber);
    if (currentSchema != null)
    {      
    	ArrayList<String > attributes = currentSchema.getAttributes();
    	String value = attributes.get(pos);    	
    	return value;
   }
    else
    	return null;	    
    
  }}PARSER_END(ParserQueryToDatalogToJava)SKIP :{  " "| "\r"| "\t"| "\n"}TOKEN :{
  < get : "get" >| < add : "add" >| < delete : "delete" >| < copy : "copy" >| < move : "move" >| < string : "\"" (~[ "\"" ])* "\"" >}String getDatalogRules() :{  String value = null;}{  value = start() < EOF >  {    return value;  }}

ArrayList<Rule > getJavaRules():
{
  String value = null;
}
{
  value = start() < EOF >
  {
    return rules;
  }
}
  String start() :{  String value = null;}{  (
    value = get()  | value = add()  | value = delete()  | value = copy()  | value = move()  )  {    return value;  }}

String get() :{  Token kindToken = null;  Token propertyToken = null;
  Token idToken = null;  }{  < get > kindToken = < string > "." propertyToken = < string > "=" idToken = < string >   {    String kind = kindToken.toString();        kind = kind.substring(1, kind.length() - 1);    String id = idToken.toString();    id = id.substring(1, id.length() - 1);    kindStr=kind;    idStr=id;    ArrayList<String > schema = getCurrentSchema(kind);    int currentVersion = getCurrentSchemaVersion(kind);    String residualRules = getResidualRules(kind);        String headRule = "get" + kind + currentVersion + "(" + schemaToString(schema) + ",?ts):-" + kind + currentVersion + "(" + schemaToString(schema) + ", ?ts), latest" + kind + currentVersion +"(?id,?ts),?id="+id+".\n";	try	{  	 	rules.addAll((new ParserRuleToJava(new StringReader(headRule))).parseHeadRules());	} catch (parserRuletoJava.ParseException e) {		// TODO Auto-generated catch block		e.printStackTrace();	} 	    return residualRules + headRule;  }}
String add() :{  Token kindToken = null;  Token propertyToken = null;  Token valueToken = null;}{  < add > kindToken = < string > "." propertyToken = < string > "=" valueToken = < string >  {    String propertyName = propertyToken.toString();    propertyName = propertyName.substring(1, propertyName.length() - 1);    String propertyValue = valueToken.toString();    propertyValue = propertyValue.substring(1, propertyValue.length() - 1);    String kind = kindToken.toString();    kind = kind.substring(1, kind.length() - 1);    ArrayList < String > currentSchema = getCurrentSchema(kind);    ArrayList < String > newSchema = getNewSchemaAdd(kind, "?" + propertyName);    int currentSchemaVersion = getCurrentSchemaVersion(kind);    int newSchemaVersion = currentSchemaVersion + 1;    String residualRules = getResidualRules(kind);
    String headRules = kind + newSchemaVersion + "(" + schemaToString(getNewSchemaAdd(kind, propertyValue)) + "," + getTimestamp() + "):-" +     kind + currentSchemaVersion + "(" + schemaToString(currentSchema) + ",?ts), latest" + kind + currentSchemaVersion + "(?id, ?ts).\n";    saveCurrentSchema(kind, newSchema);

    try
	{  
	 	rules.addAll((new ParserRuleToJava(new StringReader(headRules))).parseHeadRules());
	} catch (parserRuletoJava.ParseException e) {
		// TODO Auto-generated catch block
		e.printStackTrace();
	}    return headRules + residualRules;  }}String delete() :{  Token kindToken = null;  Token propertyToken = null;}{  < delete > kindToken = < string > "." propertyToken = < string >  {    String propertyName = propertyToken.toString();    propertyName = propertyName.substring(1, propertyName.length() - 1);    String kind = kindToken.toString();    kind = kind.substring(1, kind.length() - 1);    ArrayList < String > schema = getCurrentSchema(kind);    ArrayList < String > newSchema = getNewSchemaDelete(kind, propertyName);    int currentVersion = getCurrentSchemaVersion(kind);    int newVersion = currentVersion + 1;    String residualRules = getResidualRules(kind);    String headRules = kind + newVersion + "(" + schemaToString(newSchema) + "," + getTimestamp() + "):-" +     kind + currentVersion + "(" + schemaToString(schema) + ",?ts), latest" + kind + currentVersion + "(?id, ?ts).\n";    saveCurrentSchema(kind, newSchema);

        try
	{  
	 	rules.addAll((new ParserRuleToJava(new StringReader(headRules))).parseHeadRules());
	} catch (parserRuletoJava.ParseException e) {
		// TODO Auto-generated catch block
		e.printStackTrace();
	}
	    return residualRules + headRules;  }}String copy() :{  Token kindFromToken = null;  Token kindToToken = null;  Token propertyToken = null;  Token conditionFromToken = null;  Token conditionToToken = null;}{  < copy > kindFromToken = < string > "." propertyToken = < string > " to " kindToToken = < string >   " where " kindFromToken = < string > "." conditionFromToken = < string > "=" kindToToken = < string > "." conditionToToken = < string >  {    String kindFrom = kindFromToken.toString();    kindFrom = kindFrom.substring(1, kindFrom.length() - 1);    String kindTo = kindToToken.toString();    kindTo = kindTo.substring(1, kindTo.length() - 1);    String attribute = propertyToken.toString();    attribute = attribute.substring(1, attribute.length() - 1);    String conditionFrom = conditionFromToken.toString();    conditionFrom = conditionFrom.substring(1, conditionFrom.length() - 1);    String conditionTo = conditionToToken.toString();    conditionTo = conditionTo.substring(1, conditionTo.length() - 1);    String residualRules = getResidualRules(kindFrom) + getResidualRules(kindTo);    ArrayList < String > schemaFrom = getCurrentSchema(kindFrom);    ArrayList < String > schemaTo = getCurrentSchema(kindTo);    ArrayList < String > schemaToNew = getNewSchemaAdd(kindTo, "?" + attribute);    ArrayList < String > schemaToNew2 = getNewSchemaAdd(kindTo, "''");    int currentSchemaVersionTo = getCurrentSchemaVersion(kindTo);    int currentSchemaVersionFrom = getCurrentSchemaVersion(kindFrom);    int newSchemaVersionTo = currentSchemaVersionTo + 1;    saveCurrentSchema(kindTo, schemaToNew);    schemaFrom.set(0, "?id2");    schemaTo.set(0, "?id1");    schemaToNew.set(0, "?id1");    schemaToNew2.set(0, "?id1");    if (conditionFrom.equals("id")) conditionFrom = conditionFrom + "2";    if (conditionTo.equals("id")) conditionTo = conditionTo + "1";    String condition = "?" + conditionFrom + " = " + "?" + conditionTo;    String headRules = kindTo + newSchemaVersionTo + "(" + schemaToString(schemaToNew) + "," + getTimestamp() + "):-"     + kindTo + currentSchemaVersionTo + "(" + schemaToString(schemaTo) + ",?ts1),latest" + kindTo + currentSchemaVersionTo + "(?id1, ?ts1),"     + kindFrom + currentSchemaVersionFrom + "(" + schemaToString(schemaFrom) + ",?ts2), latest" + kindFrom + currentSchemaVersionFrom + "(?id2, ?ts2),"     + condition + ".\n";    headRules = headRules + kindTo + newSchemaVersionTo + "(" + schemaToString(schemaToNew2) + "," + getTimestamp() + "):-"     + kindTo + currentSchemaVersionTo + "(" + schemaToString(schemaTo) + ",?ts1),latest" + kindTo + currentSchemaVersionTo + "(?id1, ?ts1),"     + " not " + kindFrom + currentSchemaVersionFrom + "(" + schemaToString(schemaFrom) + ",?ts2),"     + condition + ".\n";

    try
	{  
	 	rules.addAll((new ParserRuleToJava(new StringReader(headRules))).parseHeadRules());
	} catch (parserRuletoJava.ParseException e) {
		// TODO Auto-generated catch block
		e.printStackTrace();
	}
	
    return residualRules + headRules;  }}String move() :{  Token kindFromToken = null;  Token kindToToken = null;  Token propertyToken = null;  Token conditionFromToken = null;  Token conditionToToken = null;}{  < move > kindFromToken = < string > "." propertyToken = < string > " to " kindToToken = < string >   " where " kindFromToken = < string > "." conditionFromToken = < string > "=" kindToToken = < string > "." conditionToToken = < string >  {    String kindFrom = kindFromToken.toString();    kindFrom = kindFrom.substring(1, kindFrom.length() - 1);    String kindTo = kindToToken.toString();    kindTo = kindTo.substring(1, kindTo.length() - 1);    String attribute = propertyToken.toString();    attribute = attribute.substring(1, attribute.length() - 1);    String conditionFrom = conditionFromToken.toString();    conditionFrom = conditionFrom.substring(1, conditionFrom.length() - 1);    String conditionTo = conditionToToken.toString();    conditionTo = conditionTo.substring(1, conditionTo.length() - 1);    String residualRules = getResidualRules(kindFrom) + getResidualRules(kindTo);    ArrayList < String > schemaFrom = getCurrentSchema(kindFrom);    ArrayList < String > schemaTo = getCurrentSchema(kindTo);    ArrayList < String > schemaFromNew = getNewSchemaDelete(kindFrom, attribute);    ArrayList < String > schemaToNew = getNewSchemaAdd(kindTo, "?" + attribute);    ArrayList < String > schemaToNew2 = getNewSchemaAdd(kindTo, "''");    int currentSchemaVersionFrom = getCurrentSchemaVersion(kindFrom);    int newSchemaVersionFrom = currentSchemaVersionFrom + 1;    int currentSchemaVersionTo = getCurrentSchemaVersion(kindTo);    int newSchemaVersionTo = currentSchemaVersionTo + 1;    if (conditionFrom.equals("id")) conditionFrom = conditionFrom + "2";    if (conditionTo.equals("id")) conditionTo = conditionTo + "1";    saveCurrentSchema(kindFrom, schemaFromNew);    saveCurrentSchema(kindTo, schemaToNew);    schemaFrom.set(0, "?id2");    schemaFromNew.set(0, "?id2");    schemaTo.set(0, "?id1");    schemaToNew.set(0, "?id1");    schemaToNew2.set(0, "?id1");    String condition = "?" + conditionFrom + " = " + "?" + conditionTo;    String headRules = kindTo + newSchemaVersionTo + "(" + schemaToString(schemaToNew) + "," + getTimestamp() + "):-"     + kindTo + currentSchemaVersionTo + "(" + schemaToString(schemaTo) + ",?ts1),latest" + kindTo + currentSchemaVersionTo + "(?id1,?ts1),"     + kindFrom + currentSchemaVersionFrom + "(" + schemaToString(schemaFrom) + ",?ts2), latest" + kindFrom + currentSchemaVersionFrom + "(?id2,?ts2),"     + condition + ".\n";    headRules = headRules + kindTo + newSchemaVersionTo + "(" + schemaToString(schemaToNew2) + "," + getTimestamp() + "):-"     + kindTo + currentSchemaVersionTo + "(" + schemaToString(schemaTo) + ",?ts1),latest" + kindTo + currentSchemaVersionTo + "(?id1,?ts1),"     + " not " + kindFrom + currentSchemaVersionFrom + "(" + schemaToString(schemaFrom) + ",?ts2),"     + condition + ".\n";    headRules = headRules + kindFrom + newSchemaVersionFrom + "(" + schemaToString(schemaFromNew) + "," + getTimestamp() + "):-"     + kindFrom + currentSchemaVersionFrom + "(" + schemaToString(schemaFrom) + ",?ts2), latest" + kindFrom + currentSchemaVersionFrom + "(?id2,?ts2).\n";
    try
	{  
	 	rules.addAll((new ParserRuleToJava(new StringReader(headRules))).parseHeadRules());
	} catch (parserRuletoJava.ParseException e) {
		// TODO Auto-generated catch block
		e.printStackTrace();
	}
	
    return residualRules + headRules;  }}